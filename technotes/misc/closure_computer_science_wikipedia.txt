From <http://en.wikipedia.org/wiki/Closure_(computer_science)#Closure-like_constructs>:

# Closure (computer science)

From Wikipedia, the free encyclopedia

Jump to: [navigation][1], [search][2]

   [1]: #mw-head
   [2]: #p-search

In [computer science][3], a **closure** (also **lexical closure** or **function closure**) is a [function][4] together with a _referencing environment_ for the [non-local variables][5] of that function. [[1]][6] A closure allows a function to access variables outside its immediate lexical scope. An **upvalue** is a [free variable][7] that has been bound (closed over) with a closure. The closure is said to "close over" its upvalues. The referencing environment [binds][8] the nonlocal names to the corresponding variables in [scope][9] at the time the closure is created, additionally extending their lifetime to at least as long as the lifetime of the closure itself. When the closure is _entered_ at a later time, possibly from a different scope, the function is executed with its non-local variables referring to the ones captured by the closure.

   [3]: /wiki/Computer_science (Computer science)
   [4]: /wiki/Function_(computer_science) (Function (computer science))
   [5]: /wiki/Non-local_variable (Non-local variable)
   [6]: #cite_note-0
   [7]: /wiki/Free_variable (Free variable)
   [8]: /wiki/Name_binding (Name binding)
   [9]: /wiki/Scope_(computer_science) (Scope (computer science))

The concept of closures was developed in the 1960s and was first fully implemented as a language feature in the programming language [Scheme][10] to support [lexically scoped][11] [first-class functions][12] in 1975. Since then, many languages have been designed to support closures. The explicit use of closures is associated with [functional programming][13] and with languages such as [ML][14] and [Lisp][15]. Traditional imperative languages (such as [Algol][16], [C][17] and [Pascal][18]) had no support for closures as these languages neither support nonlocal names (which can be introduced only in nested or anonymous functions) nor [higher-order functions][19]. Modern garbage-collected imperative languages (such as [Smalltalk][20], the first object-oriented language featuring closures, [[2]][21] [C#][22], but notably not [Java][23][[3]][24]) and many interpreted and scripting languages do support higher-order functions and closures.

   [10]: /wiki/Scheme_(programming_language) (Scheme (programming language))
   [11]: /wiki/Lexically_scoped (Lexically scoped)
   [12]: /wiki/First-class_function (First-class function)
   [13]: /wiki/Functional_programming (Functional programming)
   [14]: /wiki/ML_(programming_language) (ML (programming language))
   [15]: /wiki/Lisp_(programming_language) (Lisp (programming language))
   [16]: /wiki/Algol_(programming_language) (Algol (programming language))
   [17]: /wiki/C_(programming_language) (C (programming language))
   [18]: /wiki/Pascal_(programming_language) (Pascal (programming language))
   [19]: /wiki/Higher-order_function (Higher-order function)
   [20]: /wiki/Smalltalk (Smalltalk)
   [21]: #cite_note-1
   [22]: /wiki/C_Sharp_(programming_language) (C Sharp (programming language))
   [23]: /wiki/Java_(programming_language) (Java (programming language))
   [24]: #cite_note-2

Closures are used to implement [continuation-passing style][25], and in this manner, [hide state][26]. Constructs such as [objects][27] and [control structures][28] can thus be implemented with closures. In some languages, a closure may occur when a function is defined within another function, and the inner function refers to local variables of the outer function. At [run-time][29], when the outer function executes, a closure is formed, consisting of the inner function’s code and references (the upvalues) to any variables of the outer function required by the closure.

   [25]: /wiki/Continuation-passing_style (Continuation-passing style)
   [26]: /wiki/Information_hiding (Information hiding)
   [27]: /wiki/Object_(computer_science) (Object (computer science))
   [28]: /wiki/Control_structure (Control structure)
   [29]: /wiki/Run_time_(program_lifecycle_phase) (Run time (program lifecycle phase))

Closures are closely related to [function objects][30]; the transformation from the former to the latter is known as [defunctionalization][31] or [lambda lifting][32].[_[citation needed][33]_]

   [30]: /wiki/Function_object (Function object)
   [31]: /wiki/Defunctionalization (Defunctionalization)
   [32]: /wiki/Lambda_lifting (Lambda lifting)
   [33]: /wiki/Wikipedia:Citation_needed (Wikipedia:Citation needed)

## Contents

  * [1 History and etymology][34]
  * [2 Example][35]
  * [3 Implementation and theory][36]
  * [4 Applications][37]

   [34]: #History_and_etymology
   [35]: #Example
   [36]: #Implementation_and_theory
   [37]: #Applications

    * [4.1 First-class functions][38]
    * [4.2 State representation][39]
    * [4.3 Other uses][40]

   [38]: #First-class_functions
   [39]: #State_representation
   [40]: #Other_uses

  * [5 Differences in semantics][41]

   [41]: #Differences_in_semantics

    * [5.1 Lexical environment][42]
    * [5.2 Closure leaving][43]

   [42]: #Lexical_environment
   [43]: #Closure_leaving

  * [6 Closure-like constructs][44]

   [44]: #Closure-like_constructs

    * [6.1 C][45]
    * [6.2 Local classes (Java)][46]
    * [6.3 Blocks (C, C++, Objective-C 2.0)][47]
    * [6.4 Delegates (C#, D)][48]
    * [6.5 Function objects (C++)][49]
    * [6.6 Inline agents (Eiffel)][50]
    * [6.7 Erlang][51]
    * [6.8 Go][52]

   [45]: #C
   [46]: #Local_classes_.28Java.29
   [47]: #Blocks_.28C.2C_C.2B.2B.2C_Objective-C_2.0.29
   [48]: #Delegates_.28C.23.2C_D.29
   [49]: #Function_objects_.28C.2B.2B.29
   [50]: #Inline_agents_.28Eiffel.29
   [51]: #Erlang
   [52]: #Go

  * [7 See also][53]
  * [8 References][54]
  * [9 External links][55]

   [53]: #See_also
   [54]: #References
   [55]: #External_links

## [[edit][56]] History and etymology

   [56]: /w/index.php?title=Closure_(computer_science)&action=edit&section=1 (Edit section: History and etymology)

[Peter J. Landin][57] defined the term _closure_ in 1964 as having an _environment part_ and a _control part_ as used by his [SECD machine][58] for evaluating expressions.[[4]][59] [Joel Moses][60] credits Landin with introducing the term _closure_ to refer to a [lambda expression][61] whose open bindings (free variables) have been closed by (or bound in) the lexical environment, resulting in a _closed expression_, or closure.[[5]][62][[6]][63] This usage was subsequently adopted by [Sussman][64] and [Steele][65] when they defined [Scheme][66] in 1975,[[7]][67] and became widespread.

   [57]: /wiki/Peter_J._Landin (Peter J. Landin)
   [58]: /wiki/SECD_machine (SECD machine)
   [59]: #cite_note-3
   [60]: /wiki/Joel_Moses (Joel Moses)
   [61]: /wiki/Lambda_expression (Lambda expression)
   [62]: #cite_note-4
   [63]: #cite_note-5
   [64]: /wiki/Gerald_Jay_Sussman (Gerald Jay Sussman)
   [65]: /wiki/Guy_L._Steele,_Jr. (Guy L. Steele, Jr.)
   [66]: /wiki/Scheme_(programming_language) (Scheme (programming language))
   [67]: #cite_note-6

The term _closure_ is often mistakenly used to mean [anonymous function][68]. This is probably because most languages implementing anonymous functions allow them to form closures and programmers are usually introduced to both concepts at the same time. An anonymous function can be seen as a function _literal_, while a closure is a function _value_. These are, however, distinct concepts. A closure retains a reference to the environment at the time it was created (for example, to the current value of a local variable in the enclosing scope) while a generic anonymous function need not do this.

   [68]: /wiki/Anonymous_function (Anonymous function)

## [[edit][69]] Example

   [69]: /w/index.php?title=Closure_(computer_science)&action=edit&section=2 (Edit section: Example)

The following [Python 3][70] snippet defines a function `counter` with a local variable `x` and a [nested function][71] `increment`. This nested function `increment` has access to `x`, from which point of view it is a non-local variable. The function `counter` returns a closure containing a reference to the function `increment` and the `increment`'s non-local variable `x`.
    
       [70]: /wiki/Python_(programming_language) (Python (programming language))
   [71]: /wiki/Nested_function (Nested function)


    def counter():
        x = 0
        def increment(y):
            nonlocal x
            x += y
            print(x)
        return increment
     
    counter1_increment = counter()
    counter2_increment = counter()
     
    counter1_increment(1)              # prints 1
    counter1_increment(7)              # prints 8
    counter2_increment(1)              # prints 1
    counter1_increment(1)              # prints 9
    

## [[edit][72]] Implementation and theory

   [72]: /w/index.php?title=Closure_(computer_science)&action=edit&section=3 (Edit section: Implementation and theory)

Closures are typically implemented with a special [data structure][73] that contains a pointer to the function code, plus a representation of the function's lexical environment (e.g., the set of available variables and their values) at the time when the closure was created.

   [73]: /wiki/Data_structure (Data structure)

A language implementation cannot easily support full closures if its run-time memory model allocates all local variables on a linear [stack][74]. In such languages, a function's local variables are deallocated when the function returns. However, a closure requires that the free variables it references survive the enclosing function's execution. Therefore, those variables must be allocated so that they persist until no longer needed. This explains why, typically, languages that natively support closures also use [garbage collection][75]. The alternative is for the language to accept that certain use cases will lead to [undefined behaviour][76], as in the proposal for lambda expressions in C++.[[8]][77] The [Funarg problem][78] (or "functional argument" problem) describes the difficulty of implementing functions as first class objects in a stack-based programming language such as C or C++. Similarly in [D][79] version 1, it is assumed that the programmer knows what to do with delegates and local variables, as their references will be invalid after return from its definition scope (local variables are on the stack) - this still permits many useful functional patterns, but for complex cases needs explicit [heap allocation][80] for variables. D version 2 solved this by detecting which variables must be stored on the heap, and performs automatic allocation. Because D uses garbage collection, in both versions, there is no need to track usage of variables as they are passed.

   [74]: /wiki/Stack-based_memory_allocation (Stack-based memory allocation)
   [75]: /wiki/Garbage_collection_(computer_science) (Garbage collection (computer science))
   [76]: /wiki/Undefined_behaviour (Undefined behaviour)
   [77]: #cite_note-7
   [78]: /wiki/Funarg_problem (Funarg problem)
   [79]: /wiki/D_(programming_language) (D (programming language))
   [80]: /wiki/Dynamic_memory_allocation#Dynamic_memory_allocation (Dynamic memory allocation)

In strict functional languages with immutable data (_e.g._ [Erlang][81]), it is very easy to implement automatic memory management (garbage collection), as there are no possible cycles in variables references. For example in Erlang, all arguments and variables are allocated on the heap, but references to them are additionally stored on the stack. After a function returns, references are still valid. Heap cleaning is done by incremental garbage collector.

   [81]: /wiki/Erlang_(programming_language) (Erlang (programming language))

In ML, local variables are allocated on a linear stack[_[citation needed][82]_]. When a closure is created, it copies the values of those variables that are needed by the closure into the closure's data structure.

   [82]: /wiki/Wikipedia:Citation_needed (Wikipedia:Citation needed)

[Scheme][83], which has an [ALGOL][84]-like lexical scope system with dynamic variables and garbage collection, lacks a stack programming model and does not suffer from the limitations of stack-based languages. Closures are expressed naturally in Scheme. The lambda form encloses the code and the free variables of its environment, persists within the program as long as it can possibly be accessed, and can be used as freely as any other Scheme expression.

   [83]: /wiki/Scheme_(programming_language) (Scheme (programming language))
   [84]: /wiki/ALGOL (ALGOL)

Closures are closely related to Actors in the [Actor model][85] of concurrent computation where the values in the function's lexical environment are called _acquaintances_. An important issue for closures in [concurrent programming][86] languages is whether the variables in a closure can be updated and, if so, how these updates can be synchronized. Actors provide one solution.[[9]][87]

   [85]: /wiki/Actor_model (Actor model)
   [86]: /wiki/Concurrent_programming (Concurrent programming)
   [87]: #cite_note-8

## [[edit][88]] Applications

   [88]: /w/index.php?title=Closure_(computer_science)&action=edit&section=4 (Edit section: Applications)

### [[edit][89]] First-class functions

   [89]: /w/index.php?title=Closure_(computer_science)&action=edit&section=5 (Edit section: First-class functions)

Further information: [First-class function][90]

   [90]: /wiki/First-class_function (First-class function)

Closures typically appear in languages in which functions are [first-class values][91]—in other words, such languages allow functions to be passed as arguments, returned from function calls, bound to variable names, etc., just like simpler types such as strings and integers. For example, consider the following Scheme function:
    
       [91]: /wiki/First-class_object (First-class object)


    ; Return a list of all books with at least THRESHOLD copies sold.
    (define (best-selling-books threshold)
      (filter
        (lambda (book)
          (>= (book-sales book) threshold))
       book-list))
    

In this example, the [lambda expression][92] `(lambda (book) (>= (book-sales book) threshold))` appears within the function `best-selling-books`. When the lambda expression is evaluated, Scheme creates a closure consisting of the code for the lambda expression and a reference to the `threshold` variable, which is a [free variable][93] inside the lambda expression.

   [92]: /wiki/Lambda_expression (Lambda expression)
   [93]: /wiki/Free_variable (Free variable)

The closure is then passed to the `filter` function, which calls it repeatedly to determine which books are to be added to the result list and which are to be discarded. Because the closure itself has a reference to `threshold`, it can use that variable each time `filter` calls it. The function `filter` itself might be defined in a completely separate file.

Here is the same example rewritten in [JavaScript][94], another popular language with support for closures:
    
       [94]: /wiki/JavaScript (JavaScript)


    // Return a list of all books with at least 'threshold' copies sold.
    function bestSellingBooks(threshold) {
      return bookList.filter(
          function (book) { return book.sales >= threshold; }
        );
    }
    

The `function` keyword is used here instead of `lambda`, and an `Array.filter` method[[10]][95] instead of a global `filter` function, but otherwise the structure and the effect of the code are the same.

   [95]: #cite_note-9

A function may create a closure and return it, as in the following example:
    
    
    // Return a function that approximates the derivative of f
    // using an interval of dx, which should be appropriately small.
    function derivative(f, dx) {
      return function (x) {
        return (f(x + dx) - f(x)) / dx;
      };
    }
    

Because the closure in this case outlives the [scope][96] of the function that creates it, the variables `f` and `dx` live on after the function `derivative` returns. In languages without closures, the lifetime of a local variable coincides with the execution of the scope where that variable is declared. In languages with closures, variables must continue to exist as long as any existing closures have references to them. This is most commonly implemented using some form of [garbage collection][97].

   [96]: /wiki/Scope_(programming) (Scope (programming))
   [97]: /wiki/Garbage_collection_(computer_science) (Garbage collection (computer science))

### [[edit][98]] State representation

   [98]: /w/index.php?title=Closure_(computer_science)&action=edit&section=6 (Edit section: State representation)

A closure can be used to associate a function with a set of "private" variables, which persist over several invocations of the function. The [scope][99] of the variable encompasses only the closed-over function, so it cannot be accessed from other program code.

   [99]: /wiki/Scope_(programming) (Scope (programming))

In stateful languages, closures can thus be used to implement paradigms for state representation and [information hiding][100], since the closure's upvalues (its closed-over variables) are of indefinite [extent][101], so a value established in one invocation remains available in the next. Closures used in this way no longer have [referential transparency][102], and are thus no longer [pure functions][103]; nevertheless, they are commonly used in "near-functional" languages such as [Scheme][104].

   [100]: /wiki/Information_hiding (Information hiding)
   [101]: /wiki/Variable_(programming)#Scope_and_extent (Variable (programming))
   [102]: /wiki/Referential_transparency_(computer_science) (Referential transparency (computer science))
   [103]: /wiki/Pure_function (Pure function)
   [104]: /wiki/Scheme_(programming_language) (Scheme (programming language))

### [[edit][105]] Other uses

   [105]: /w/index.php?title=Closure_(computer_science)&action=edit&section=7 (Edit section: Other uses)

Closures have many uses:

  * Because closures delay evaluation—i.e., they do not "do" anything until they are called—they can be used to define control structures. For example, all [Smalltalk][106]'s standard control structures, including branches (if/then/else) and loops (while and for), are defined using objects whose methods accept closures. Users can easily define their own control structures also.
  * In languages that allow assignment, multiple functions can be produced that close over the same environment, enabling them to communicate privately by altering that environment. In Scheme:
    
       [106]: /wiki/Smalltalk (Smalltalk)


    (define foo #f)
    (define bar #f)
     
    (let ((secret-message "none"))
      (set! foo (lambda (msg) (set! secret-message msg)))
      (set! bar (lambda () secret-message)))
     
    (display (bar)) ; prints "none"
    (newline)
    (foo "meet me by the docks at midnight")
    (display (bar)) ; prints "meet me by the docks at midnight"
    

  * Closures can be used to implement [object][107] systems.[[11]][108]

   [107]: /wiki/Object-oriented_programming (Object-oriented programming)
   [108]: #cite_note-10

Note: Some speakers call any data structure that binds a [lexical][109] environment a closure, but the term usually refers specifically to functions.

   [109]: /wiki/Scope_(programming)#Lexical_scoping (Scope (programming))

## [[edit][110]] Differences in semantics

   [110]: /w/index.php?title=Closure_(computer_science)&action=edit&section=8 (Edit section: Differences in semantics)

### [[edit][111]] Lexical environment

   [111]: /w/index.php?title=Closure_(computer_science)&action=edit&section=9 (Edit section: Lexical environment)

As different languages do not always have a common definition of the lexical environment, their definitions of closure may vary also. The commonly held minimalist definition of the lexical environment defines it as a set of all [bindings of variables][112] in the scope, and that is also what closures in any language have to capture. However the meaning of a [variable][113] binding also differs. In imperative languages, variables bind to relative locations in memory that can store values. Although the relative location of a binding does not change at runtime, the value in the bound location can. In such languages, since closure captures the binding, any operation on the variable, whether done from the closure or not, are performed on the same relative memory location. This is often called capturing the variable "by reference". Here is an example illustrating the concept in [ECMAScript][114], which is one such language:
    
       [112]: /wiki/Name_binding (Name binding)
   [113]: /wiki/Variable_(programming) (Variable (programming))
   [114]: /wiki/ECMAScript (ECMAScript)


    // ECMAScript
    var f, g;
    function foo() {
      var x = 0;
      f = function() { return ++x; };
      g = function() { return --x; };
      x = 1;
      alert('inside foo, call to f(): ' + f()); // "2"
    }
    foo();
    alert('call to g(): ' + g()); // "1"
    alert('call to f(): ' + f()); // "2"
    

Note how function `foo` and the closures referred to by variables `f` and `g` all use the same relative memory location signified by local variable `x`.

On the other hand, many functional languages, such as [ML][115], bind variables directly to values. In this case, since there is no way to change the value of the variable once it is bound, there is no need to share the state between closures—they just use the same values. This is often called capturing the variable "by value". Java's local and anonymous classes also fall into this category -- they required captured local variables to be `final`, which also means there is no need to share state.

   [115]: /wiki/ML_(programming_language) (ML (programming language))

Some languages allow you to choose between capturing the value of a variable or its location. For example, in C++11 and PHP, captured variables are either declared with `&`, which means captured by reference, or without, which means captured by value.

Yet another subset, [lazy][116] functional languages such as [Haskell][117], bind variables to results of future computations rather than values. Consider this example in Haskell:
    
       [116]: /wiki/Lazy_evaluation (Lazy evaluation)
   [117]: /wiki/Haskell_(programming_language) (Haskell (programming language))


    -- Haskell
    foo :: Num -> Num -> (Num -> Num)
    foo x y = let r = x / y
              in (\z -> z + r)
     
    f :: Num -> Num
    f = foo 1 0
     
    main = print (f 123)
    

The binding of `r` captured by the closure defined within function `foo` is to the computation `(x / y)` - which in this case results in division by zero. However, since it is the computation that is captured, and not the value, the error only manifests itself when the closure is invoked, and actually attempts to use the captured binding.

### [[edit][118]] Closure leaving

   [118]: /w/index.php?title=Closure_(computer_science)&action=edit&section=10 (Edit section: Closure leaving)

Yet more differences manifest themselves in the behavior of other lexically scoped constructs, such as `return`, `break` and `continue` statements. Such constructs can, in general, be considered in terms of invoking an [escape continuation][119] established by an enclosing control statement (in case of `break` and `continue`, such interpretation requires looping constructs to be considered in terms of recursive function calls). In some languages, such as ECMAScript, `return` refers to the continuation established by the closure lexically innermost with respect to the statement—thus, a `return` within a closure transfers control to the code that called it. However in [Smalltalk][120], the superficially similar operator `^` invokes the escape continuation established for the method invocation, ignoring the escape continuations of any intervening nested closures. The escape continuation of a particular closure can only be invoked in Smalltalk implicitly by reaching the end of the closure's code. The following examples in ECMAScript and Smalltalk highlight the difference:
    
       [119]: /wiki/Escape_continuation (Escape continuation)
   [120]: /wiki/Smalltalk (Smalltalk)


    "Smalltalk"
    foo
      | xs |
      xs := #(1 2 3 4).
      xs do: [:x | ^x].
      ^0
    bar
      Transcript show: (self foo printString) "prints 1"
    
    
    
    // ECMAScript
    function foo() {
      var xs = [1, 2, 3, 4];
      xs.forEach(function (x) { return x; });
      return 0;
    }
    alert(foo()); // prints 0
    

The above code snippets will behave differently because the Smalltalk `^` operator and the JavaScript `return` operator are not analogous. In the ECMAScript example, `return x` will leave the inner closure to begin a new iteration of the `forEach` loop, whereas in the Smalltalk example, `^x` will abort the loop and return from the method `foo`.

[Common Lisp][121] provides a construct that can express either of the above actions: Lisp `(return-from foo x)` behaves as [Smalltalk][122] `^x`, while Lisp `(return-from nil x)` behaves as [JavaScript][123] `return x`. Hence, Smalltalk makes it possible for a captured escape continuation to outlive the extent in which it can be successfully invoked. Consider:
    
       [121]: /wiki/Common_Lisp (Common Lisp)
   [122]: /wiki/Smalltalk (Smalltalk)
   [123]: /wiki/JavaScript (JavaScript)


    "Smalltalk"
    foo
        ^[ :x | ^x ]
    bar
        | f |
        f := self foo.
        f value: 123 "error!"
    

When the closure returned by the method `foo` is invoked, it attempts to return a value from the invocation of `foo` that created the closure. Since that call has already returned and the Smalltalk method invocation model does not follow the [spaghetti stack][124] discipline to allow multiple returns, this operation results in an error.

   [124]: /wiki/Spaghetti_stack (Spaghetti stack)

Some languages, such as [Ruby][125], allow the programmer to choose the way `return` is captured. An example in Ruby:
    
       [125]: /wiki/Ruby_(programming_language) (Ruby (programming language))


    # Ruby
     
    # Closure using a Proc
    def foo
      f = Proc.new { return "return from foo from inside proc" }
      f.call # control leaves foo here
      return "return from foo"
    end
     
    # Closure using a lambda
    def bar
      f = lambda { return "return from lambda" }
      f.call # control does not leave bar here
      return "return from bar"
    end
     
    puts foo # prints "return from foo from inside proc"
    puts bar # prints "return from bar"
    

Both `Proc.new` and `lambda` in this example are ways to create a closure, but semantics of the closures thus created are different with respect to the `return` statement.

In [Scheme][126], definition and scope of the `return` control statement is explicit (and only arbitrarily named 'return' for the sake of the example). The following is a direct translation of the Ruby sample.
    
       [126]: /wiki/Scheme_(programming_language) (Scheme (programming language))


    ; Scheme
    (define call/cc call-with-current-continuation)
     
    (define (foo)
      (call/cc
       (lambda (return)
         (define (f) (return "return from foo from inside proc"))
         (f) ; control leaves foo here
         (return "return from foo"))))
     
    (define (bar)
      (call/cc
       (lambda (return)
         (define (f) (call/cc (lambda (return) (return "return from lambda"))))
         (f) ; control does not leave bar here
         (return "return from bar"))))
     
    (display (foo)) ; prints "return from foo from inside proc"
    (newline)
    (display (bar)) ; prints "return from bar"
    

## [[edit][127]] Closure-like constructs

   [127]: /w/index.php?title=Closure_(computer_science)&action=edit&section=11 (Edit section: Closure-like constructs)

Features of some languages simulate some features of closures. Language features include some object-oriented techniques, for example in Java, C++, Objective-C, C#, D.

### [[edit][128]] C

   [128]: /w/index.php?title=Closure_(computer_science)&action=edit&section=12 (Edit section: C)

In [C][129], libraries that support [callbacks][130] sometimes allow a callback to be registered using two values: a function pointer and a separate `void*` pointer to arbitrary data of the user's choice. Each time the library executes the callback function, it passes in the data pointer. This allows the callback to maintain state and to refer to information captured at the time it was registered. The idiom is similar to closures in functionality, but not in syntax.

   [129]: /wiki/C_(programming_language) (C (programming language))
   [130]: /wiki/Callback_(computer_science) (Callback (computer science))

### [[edit][131]] Local classes (Java)

   [131]: /w/index.php?title=Closure_(computer_science)&action=edit&section=13 (Edit section: Local classes (Java))

[Java][132] allows [classes][133] to be defined inside [methods][134]. When such classes are not named, they are known as _anonymous classes_ (or anonymous _inner_ classes) An anonymous class may refer to names in lexically enclosing classes, or read-only variables (marked as final) in the lexically enclosing method.
    
       [132]: /wiki/Java_(programming_language) (Java (programming language))
   [133]: /wiki/Class_(object-oriented_programming) (Class (object-oriented programming))
   [134]: /wiki/Method_(object-oriented_programming) (Method (object-oriented programming))


    class CalculationWindow extends JFrame {
      private volatile int result;
      ...
      public void calculateInSeparateThread(final URI uri) {
        // The expression "new Runnable() { ... }" is an anonymous class implementing the 'Runnable' interface.
        new Thread(
          new Runnable() {
            void run() {
              // It can read final local variables:
              calculate(uri);
              // It can access private fields of the enclosing class:
              result = result + 10;
            }
          }
        ).start();
      }
    }
    

The capturing of final variables allows you to capture variables by value. Even if the variable you want to capture is non-final, you can always copy it to a temporary final variable just before the class.

Capturing of variables by reference can be emulated by using a final reference to a mutable container, for example, a single-element array. The local class will not be able to change the value of the container reference itself, but it will be able to change the contents of the container.

According to a Java 8 proposal,[[12]][135] closures will allow the above code to be executed as:
    
       [135]: #cite_note-11


    class CalculationWindow extends JFrame {
    private volatile int result;
      ...
      public void calculateInSeparateThread(final URI uri) {
        // the code #(){ /* code */ } is a closure
        new Thread(#(){
            calculate(uri);
            result = result + 10;
        }).start();
      }
    }
    

  
Anonymous classes are one of the types of inner class that are declared within the body of a method. Java also supports inner classes that are declared as _non-static members_ of an enclosing class.[[13]][136] They are normally referred to just as "inner classes".[[14]][137] These are defined in the body of the enclosing class and have full access to each and every instance variable of the enclosing class, thus resembling standard function closures. Due to their binding to these instance variables, an inner class may only be instantiated with an explicit binding to an instance of the enclosing class using a special syntax.[[15]][138]
    
       [136]: #cite_note-12
   [137]: #cite_note-13
   [138]: #cite_note-14


    public class EnclosingClass {
      /* Define the inner class */
      public class InnerClass {
        public int incrementAndReturnCounter() {
          return counter++;
        }
      }
     
      private int counter;
     
      {
        counter = 0;
      }
     
      public int getCounter() {
        return counter;
      }
     
      public static void main(String[] args) {
        EnclosingClass enclosingClassInstance = new EnclosingClass();
        /* Instantiate the inner class, with binding to the instance */
        EnclosingClass.InnerClass innerClassInstance =
          enclosingClassInstance.new InnerClass();
     
        for(int i = enclosingClassInstance.getCounter(); (i =
        innerClassInstance.incrementAndReturnCounter()) < 10;) {
          System.out.println(i);
        }
      }
    }
    

Upon execution, this will print the integers from 0 to 9. Beware to not confuse this type of class with the so called static inner class, which is declared in the same way with an accompanied usage of the "static" modifier; those have not the desired effect but are instead just classes with no special binding defined in an enclosing class.

There have been a number of proposals for adding more fully featured closures to Java.[[16]][139][[17]][140][[18]][141]

   [139]: #cite_note-15
   [140]: #cite_note-16
   [141]: #cite_note-17

### [[edit][142]] Blocks (C, C++, Objective-C 2.0)

   [142]: /w/index.php?title=Closure_(computer_science)&action=edit&section=14 (Edit section: Blocks (C, C++, Objective-C 2.0))

[Apple][143] introduced **[Blocks][144]**, a form of closure, as a nonstandard extension into [C][145], [C++][146], [Objective-C 2.0][147] and in [Mac OS X 10.6 "Snow Leopard"][148] and [iOS 4.0][149].

   [143]: /wiki/Apple_Inc. (Apple Inc.)
   [144]: /wiki/Blocks_(C_language_extension) (Blocks (C language extension))
   [145]: /wiki/C_(programming_language) (C (programming language))
   [146]: /wiki/C%2B%2B (C++)
   [147]: /wiki/Objective-C_2.0 (Objective-C 2.0)
   [148]: /wiki/Mac_OS_X_Snow_Leopard (Mac OS X Snow Leopard)
   [149]: /wiki/IOS_(Apple) (IOS (Apple))

Pointers to block and block literals are marked with `^`. Normal local variables are captured by value when the block is created, and are read-only inside the block. Variables to be captured by reference are marked with `__block`. Blocks that need to persist outside of the scope it is created in need to be copied.[[19]][150][[20]][151]
    
       [150]: #cite_note-18
   [151]: #cite_note-19


    typedef int (^IntBlock)();
     
    IntBlock downCounter(int start) {
             __block int i = start;
             return [[ ^int() {
                     return i--;
             } copy] autorelease];
    }
     
    IntBlock f = downCounter(5);
    NSLog(@"%d", f());
    NSLog(@"%d", f());
    NSLog(@"%d", f());
    

### [[edit][152]] Delegates (C#, D)

   [152]: /w/index.php?title=Closure_(computer_science)&action=edit&section=15 (Edit section: Delegates (C#, D))

[C#][153] anonymous methods and lambda expressions support closure to local variables:
    
       [153]: /wiki/C_Sharp_(programming_language) (C Sharp (programming language))


    var data = new[] {1, 2, 3, 4};
    var multiplier = 2;
    var result = data.Select(x => x * multiplier);
    

Closures are implemented by delegates in [D][154].
    
       [154]: /wiki/D_(programming_language) (D (programming language))


    auto test1() {
        int a = 7;
        return delegate() { return a + 3; }; // anonymous delegate construction
    }
     
    auto test2() {
        int a = 20;
        int foo() { return a + 5; } // inner function
        return &foo;  // other way to construct delegate
    }
     
    void bar() {
        auto dg = test1();
        dg();    // =10   // ok, test1.a is in a closure and still exists
     
        dg = test2();
        dg();    // =25   // ok, test2.a is in a closure and still exists
    }
    

D version 1, has limited closure support. For example, the above code will not work correctly, because the variable a is on the stack, and after returning from test(), it is no longer valid to use it (most probably calling foo via dg(), will return a 'random' integer). This can be solved by explicitly allocating the variable a on heap, or using structs or class to store all needed closed variables and construct a delegate from a method implementing the same code. Closures can be passed to other functions, as long as they are only used while the referenced values are still valid (for example calling another function with a closure as a callback parameter), and are useful for writing generic data processing code, so this limitation, in practice, is often not an issue.

This limitation was fixed in D version 2 - the variable 'a' will be automatically allocated on the heap because it is used in the inner function, and a delegate of that function is allowed to escapes the current scope (via assignment to dg or return). Any other local variables (or arguments) that are not referenced by delegates or that are only referenced by delegates that don't escape the current scope, remain on the stack, which is simpler and faster than heap allocation. The same is true for inner's class methods that references a function's variables.

### [[edit][155]] Function objects (C++)

   [155]: /w/index.php?title=Closure_(computer_science)&action=edit&section=16 (Edit section: Function objects (C++))

[C++][156] allows defining [function objects][157] by overloading `operator()`. These objects behave somewhat like functions in a functional programming language. They may be created at runtime and may contain state, but they do not implicitly capture local variables as closures do. Two proposals to introduce C++ language support for closures (both proposals call them lambda functions) are being considered by the C++ Standards Committee.[[21]][158][[22]][159] The main difference between these proposals is that one stores a copy of all the local variables in a closure by default, and another stores references to original variables. Both provide functionality to override the default behavior. If some form of these proposals is accepted, one would be able to write
    
       [156]: /wiki/C%2B%2B (C++)
   [157]: /wiki/Function_object (Function object)
   [158]: #cite_note-20
   [159]: #cite_note-21


    void foo(string myname) {
        typedef vector<string> names;
        int y;
        names n;
        // ...
        names::iterator i = std::find_if(n.begin(), n.end(), [&](const string& s) {
                return s != myname && s.size() > y;
            });
        // 'i' is now either 'n.end()' or points to the first string in 'n'
        // which is not equal to 'myname' and whose length is greater than 'y'
    }
    

At least three C++ compilers, Visual C++ 2010, [Clang][160] 2.9 and [GCC][161] 4.5, already support this notation. As of 12 August 2011, the approved C++11 standard does support closures.

   [160]: /wiki/Clang (Clang)
   [161]: /wiki/GNU_Compiler_Collection (GNU Compiler Collection)

### [[edit][162]] Inline agents (Eiffel)

   [162]: /w/index.php?title=Closure_(computer_science)&action=edit&section=17 (Edit section: Inline agents (Eiffel))

[Eiffel][163] includes **inline agents** defining closures. An inline agent is an object representing a routine, defined by giving the code of the routine in-line. For example, in
    
       [163]: /wiki/Eiffel_(programming_language) (Eiffel (programming language))


    ok_button.click_event.subscribe (
            agent (x, y: INTEGER) do
                    map.country_at_coordinates (x, y).display
            end
    )
    

the argument to `subscribe` is an agent, representing a procedure with two arguments; the procedure finds the country at the corresponding coordinates and displays it. The whole agent is "subscribed" to the event type `click_event` for a certain button, so that whenever an instance of the event type occurs on that button - because a user has clicked the button - the procedure will be executed with the mouse coordinates being passed as arguments for x and y.

The main limitation of Eiffel agents, which distinguishes them from true closures, is that they cannot reference local variables from enclosing scope, but this can easily be worked around by providing additional closed operands to the agent. Only Current (a reference to current object, analogous to this in Java), its features, and arguments of the agent itself can be accessed from within the agent body.

### [[edit][164]] Erlang

   [164]: /w/index.php?title=Closure_(computer_science)&action=edit&section=18 (Edit section: Erlang)

In [Erlang][165], closures are supported simply using the keyword `fun` (Erlang's name for anonymous function) with references to outer variables. Because Erlang is a functional language with immutable value passing semantics, it is both easy to construct closures, execute them, or manage memory. Implementation is done by hidden module-level functions with N+M arguments (N: number of closed outer variables; M: number of own arguments), which is also very simple (see [Lambda lifting][166]).
    
       [165]: /wiki/Erlang_(programming_language) (Erlang (programming language))
   [166]: /wiki/Lambda_lifting (Lambda lifting)


    construct_filter(L) ->
      Filter = fun (X) -> lists:member(X, L) end,  % by using L in this fun,
      Filter.                                      % we construct closure
     
    complex_filter(SmallListOfSearchedElements, BigListToBeSearched) ->
      Filter = construct_filter(SmallListOfSearchedElements),
      Result = lists:filter(Filter, BigListToBeSearched),
      Result.
    

### [[edit][167]] Go

   [167]: /w/index.php?title=Closure_(computer_science)&action=edit&section=19 (Edit section: Go)

In [Go][168], functions are closures bound to outer variables. In the following example, function adder returns a closure that is declared as a function taking one input argument of type int and returning one value of type int. Each call of adder() returns a different closure that is bound to its own instance of variable sum.
    
       [168]: /wiki/Go_(programming_language) (Go (programming language))


    package main
     
    import "fmt"
     
    func adder() func(int) int {
            sum := 0
            return func(x int) int {
                    sum += x
                    return sum
            }
    }
     
    func main() {
            pos, neg := adder(), adder()
            for i := 0; i < 10; i++ {
                    fmt.Println(
                            pos(i),
                            neg(-2*i),
                    )
            }
    }
    

## [[edit][169]] See also

   [169]: /w/index.php?title=Closure_(computer_science)&action=edit&section=20 (Edit section: See also)

  * [Anonymous function][170]
  * [Blocks (C language extension)][171]
  * [Command pattern][172]
  * [Continuation][173]
  * [Currying][174]
  * [Funarg problem][175]
  * [Lambda calculus][176]
  * [Lazy evaluation][177]
  * [Partial application][178]
  * [Spaghetti stack][179]
  * [Syntactic closure][180]
  * [Value-level programming][181]

   [170]: /wiki/Anonymous_function (Anonymous function)
   [171]: /wiki/Blocks_(C_language_extension) (Blocks (C language extension))
   [172]: /wiki/Command_pattern (Command pattern)
   [173]: /wiki/Continuation (Continuation)
   [174]: /wiki/Currying (Currying)
   [175]: /wiki/Funarg_problem (Funarg problem)
   [176]: /wiki/Lambda_calculus (Lambda calculus)
   [177]: /wiki/Lazy_evaluation (Lazy evaluation)
   [178]: /wiki/Partial_application (Partial application)
   [179]: /wiki/Spaghetti_stack (Spaghetti stack)
   [180]: /wiki/Syntactic_closure (Syntactic closure)
   [181]: /wiki/Value-level_programming (Value-level programming)

## [[edit][182]] References

   [182]: /w/index.php?title=Closure_(computer_science)&action=edit&section=21 (Edit section: References)

  1. **[^][183]** Sussman and Steele. "Scheme: An interpreter for extended lambda calculus". "... a data structure containing a lambda expression, and an environment to be used when that lambda expression is applied to arguments." ([Wikisource][184])
  2. **[^][185]** [Closures in Java][186][_[better source needed][187]_]
  3. **[^][188]** [OpenJDK][189]: [Closures for the Java Programming Language][190], [Project Lambda][191]; [Closures (Lambda Expressions) for the Java Programming Language][192]; [James Gosling][193]. ["Closures"][194]; [Guy Steele][195]. [Re: bindings and assignments][196].
  4. **[^][197]** [P. J. Landin][198] (1964), _The mechanical evaluation of expressions_ 
  5. **[^][199]** [Joel Moses][200] (June 1970) (PDF), [_The Function of FUNCTION in LISP, or Why the FUNARG Problem Should Be Called the Environment Problem_][201], [AI Memo][202] 199, [http://dspace.mit.edu/handle/1721.1/5854][201], retrieved 2009-10-27, "A useful metaphor for the difference between FUNCTION and QUOTE in LISP is to think of QUOTE as a porous or an open covering of the function since free variables escape to the current environment. FUNCTION acts as a closed or nonporous covering (hence the term "closure" used by Landin). Thus we talk of "open" Lambda expressions (functions in LISP are usually Lambda expressions) and "closed" Lambda expressions. [...] My interest in the environment problem began while Landin, who had a deep understanding of the problem, visited MIT during 1966-67. I then realized the correspondence between the FUNARG lists which are the results of the evaluation of "closed" Lambda expressions in [LISP][203] and [ISWIM][204]'s Lambda Closures." 
  6. **[^][205]** [Åke Wikström][206] (1987). _Functional Programming using Standard ML_. [ISBN][207] [0-13-331968-7][208]. "The reason it is called a "closure" is that an expression containing free variables is called an "open" expression, and by associating to it the bindings of its free variables, you close it." 
  7. **[^][209]** [Gerald Jay Sussman][210] and [Guy L. Steele, Jr.][211] (December 1975), _Scheme: An Interpreter for the Extended Lambda Calculus_, [AI Memo][202] 349 
  8. **[^][212]** _[Lambda Expressions and Closures][213]_ C++ Standards Committee. 29 February 2008.
  9. **[^][214]** _[Foundations of Actor Semantics][215]_ Will Clinger. MIT Mathematics Doctoral Dissertation. June 1981.
  10. **[^][216]** ["array.filter"][217]. _Mozilla Developer Center_. 10 January 2010. [https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/filter][217]. Retrieved 2010-02-09. 
  11. **[^][218]** ["Re: FP, OO and relations. Does anyone trump the others?"][219]. 29 December 1999. [http://okmij.org/ftp/Scheme/oop-in-fp.txt][219]. Retrieved 2008-12-23. 
  12. **[^][220]** ["OpenJDK: Project Lambda"][191]. [http://openjdk.java.net/projects/lambda/][191]. 
  13. **[^][221]** ["Nested, Inner, Member, and Top-Level Classes"][222]. [https://blogs.oracle.com/darcy/entry/nested_inner_member_and_top][222]. 
  14. **[^][223]** ["Inner Class Example (The Java Tutorials > Learning the Java Language > Classes and Objects)"][224]. [http://java.sun.com/docs/books/tutorial/java/javaOO/innerclasses.html][224]. 
  15. **[^][225]** ["Nested Classes (The Java Tutorials > Learning the Java Language > Classes and Objects)"][226]. [http://java.sun.com/docs/books/tutorial/java/javaOO/nested.html][226]. 
  16. **[^][227]** [http://www.javac.info/][228]
  17. **[^][229]** [http://docs.google.com/View?docid=k73_1ggr36h][230]
  18. **[^][231]** [http://docs.google.com/Doc?id=ddhp95vd_0f7mcns][232]
  19. **[^][233]** Apple Inc.. ["Blocks Programming Topics"][234]. [http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html][234]. Retrieved 2011-03-08. 
  20. **[^][235]** Joachim Bengtsson (7 July 2010). ["Programming with C Blocks On Apple Devices"][236]. [http://thirdcog.eu/pwcblocks/][236]. Retrieved 2010-09-18. 
  21. **[^][237]** [JTC1/SC22/WG21 - Papers 2006 mailing2006-02-pre-Berlin][238]
  22. **[^][239]** [A proposal to add lambda functions to the C++ standard][240]

   [183]: #cite_ref-0
   [184]: //en.wikisource.org/wiki/Page:Scheme_-_An_interpreter_for_extended_lambda_calculus.djvu/22 (s:Page:Scheme - An interpreter for extended lambda calculus.djvu/22)
   [185]: #cite_ref-1
   [186]: http://www.jugpadova.it/files/Closures_in_Java.pdf
   [187]: /wiki/Wikipedia:NOTRS (Wikipedia:NOTRS)
   [188]: #cite_ref-2
   [189]: /wiki/OpenJDK (OpenJDK)
   [190]: http://openjdk.java.net/projects/closures/
   [191]: http://openjdk.java.net/projects/lambda/
   [192]: http://javac.info/
   [193]: /wiki/James_Gosling (James Gosling)
   [194]: http://blogs.oracle.com/jag/entry/closures
   [195]: /wiki/Guy_Steele (Guy Steele)
   [196]: http://article.gmane.org/gmane.comp.lang.lightweight/2274
   [197]: #cite_ref-3
   [198]: /wiki/Peter_J._Landin (Peter J. Landin)
   [199]: #cite_ref-4
   [200]: /wiki/Joel_Moses (Joel Moses)
   [201]: http://dspace.mit.edu/handle/1721.1/5854
   [202]: /wiki/AI_Memo (AI Memo)
   [203]: /wiki/LISP_1.5 (LISP 1.5)
   [204]: /wiki/ISWIM (ISWIM)
   [205]: #cite_ref-5
   [206]: /w/index.php?title=%C3%85ke_Wikstr%C3%B6m&action=edit&redlink=1 (Åke Wikström (page does not exist))
   [207]: /wiki/International_Standard_Book_Number (International Standard Book Number)
   [208]: /wiki/Special:BookSources/0-13-331968-7 (Special:BookSources/0-13-331968-7)
   [209]: #cite_ref-6
   [210]: /wiki/Gerald_Jay_Sussman (Gerald Jay Sussman)
   [211]: /wiki/Guy_L._Steele,_Jr. (Guy L. Steele, Jr.)
   [212]: #cite_ref-7
   [213]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf
   [214]: #cite_ref-8
   [215]: https://dspace.mit.edu/handle/1721.1/6935
   [216]: #cite_ref-9
   [217]: https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/filter
   [218]: #cite_ref-10
   [219]: http://okmij.org/ftp/Scheme/oop-in-fp.txt
   [220]: #cite_ref-11
   [221]: #cite_ref-12
   [222]: https://blogs.oracle.com/darcy/entry/nested_inner_member_and_top
   [223]: #cite_ref-13
   [224]: http://java.sun.com/docs/books/tutorial/java/javaOO/innerclasses.html
   [225]: #cite_ref-14
   [226]: http://java.sun.com/docs/books/tutorial/java/javaOO/nested.html
   [227]: #cite_ref-15
   [228]: http://www.javac.info/
   [229]: #cite_ref-16
   [230]: http://docs.google.com/View?docid=k73_1ggr36h
   [231]: #cite_ref-17
   [232]: http://docs.google.com/Doc?id=ddhp95vd_0f7mcns
   [233]: #cite_ref-18
   [234]: http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html
   [235]: #cite_ref-19
   [236]: http://thirdcog.eu/pwcblocks/
   [237]: #cite_ref-20
   [238]: http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2006/#mailing2006-02
   [239]: #cite_ref-21
   [240]: http://val.samko.info/lambda/

## [[edit][241]] External links

   [241]: /w/index.php?title=Closure_(computer_science)&action=edit&section=22 (Edit section: External links)

  * [The Original "Lambda Papers"][242]: A classic series of papers by [Guy Steele][243] and [Gerald Sussman][244] discussing, among other things, the versatility of closures in the context of Scheme (where they appear as _[lambda][245] expressions_).
  * [Neal Gafter][246] (2007-01-28). ["A Definition of Closures"][247]. [http://gafter.blogspot.com/2007/01/definition-of-closures.html][247]. 
  * [Gilad Bracha][248], [Neal Gafter][246], [James Gosling][249], [Peter von der Ahé][250]. ["Closures for the Java Programming Language (v0.5)"][251]. [http://www.javac.info/closures-v05.html][251]. 
  * [Closures][252]: An article about closures in [dynamically typed][253] imperative languages, by [Martin Fowler][254].
  * [Collection closure methods][255]: An example of a technical domain where using closures is convenient, by [Martin Fowler][254].

   [242]: http://library.readscheme.org/page1.html
   [243]: /wiki/Guy_Steele (Guy Steele)
   [244]: /wiki/Gerald_Sussman (Gerald Sussman)
   [245]: /wiki/Lambda_calculus (Lambda calculus)
   [246]: /w/index.php?title=Neal_Gafter&action=edit&redlink=1 (Neal Gafter (page does not exist))
   [247]: http://gafter.blogspot.com/2007/01/definition-of-closures.html
   [248]: /wiki/Gilad_Bracha (Gilad Bracha)
   [249]: /wiki/James_Gosling (James Gosling)
   [250]: /w/index.php?title=Peter_von_der_Ah%C3%A9&action=edit&redlink=1 (Peter von der Ahé (page does not exist))
   [251]: http://www.javac.info/closures-v05.html
   [252]: http://martinfowler.com/bliki/Closure.html
   [253]: /wiki/Type_system#Dynamic_typing (Type system)
   [254]: /wiki/Martin_Fowler (Martin Fowler)
   [255]: http://martinfowler.com/bliki/CollectionClosureMethod.html

Javascript

  * [What are closures][256]: A post on closures in Javascript.
  * [Javascript Closures for Dummies][257][_[dead link][258]_]: An article teaching closures in Javascript by examples.

   [256]: http://blogs.msdn.com/kartikb/archive/2009/02/08/closures.aspx
   [257]: http://blog.morrisjohns.com/javascript_closures_for_dummies.html
   [258]: /wiki/Wikipedia:Link_rot (Wikipedia:Link rot)

Java and .NET

  * [The beauty of closures][259]: An article about using closures in Java and .NET

   [259]: http://www.developerfusion.com/article/8251/the-beauty-of-closures/

Delphi

  * Nick Hodges, "[Delphi 2009 Reviewers Guide][260]", October 2008, _CodeGear Developer Network_, CodeGear.
  * Craig Stuntz, "[Understanding Anonymous Methods][261]", October 2008
  * Dr. Bob, "[Delphi 2009 Anonymous Methods][262]"

   [260]: http://dn.codegear.com/article/38757
   [261]: http://blogs.teamb.com/craigstuntz/2008/08/04/37828/
   [262]: http://www.drbob42.com/examines/examinA5.htm

Ruby

  * Robert Sosinski, "[Understanding Ruby Blocks, Procs and Lambdas][263]", December 2008

   [263]: http://www.robertsosinski.com/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/

Retrieved from "[http://en.wikipedia.org/w/index.php?title=Closure_(computer_science)&oldid=493854885][264]" 

   [264]: http://en.wikipedia.org/w/index.php?title=Closure_(computer_science)&oldid=493854885

[Categories][265]: 

   [265]: /wiki/Special:Categories (Special:Categories)

  * [Programming language concepts][266]
  * [Implementation of functional programming languages][267]
  * [Subroutines][268]

   [266]: /wiki/Category:Programming_language_concepts (Category:Programming language concepts)
   [267]: /wiki/Category:Implementation_of_functional_programming_languages (Category:Implementation of functional programming languages)
   [268]: /wiki/Category:Subroutines (Category:Subroutines)

Hidden categories: 

  * [All pages needing factual verification][269]
  * [Wikipedia articles needing factual verification from September 2011][270]
  * [All articles with unsourced statements][271]
  * [Articles with unsourced statements from September 2011][272]
  * [Articles with unsourced statements from July 2010][273]
  * [All articles with dead external links][274]
  * [Articles with dead external links from March 2012][275]
  * [Use dmy dates from February 2011][276]

   [269]: /wiki/Category:All_pages_needing_factual_verification (Category:All pages needing factual verification)
   [270]: /wiki/Category:Wikipedia_articles_needing_factual_verification_from_September_2011 (Category:Wikipedia articles needing factual verification from September 2011)
   [271]: /wiki/Category:All_articles_with_unsourced_statements (Category:All articles with unsourced statements)
   [272]: /wiki/Category:Articles_with_unsourced_statements_from_September_2011 (Category:Articles with unsourced statements from September 2011)
   [273]: /wiki/Category:Articles_with_unsourced_statements_from_July_2010 (Category:Articles with unsourced statements from July 2010)
   [274]: /wiki/Category:All_articles_with_dead_external_links (Category:All articles with dead external links)
   [275]: /wiki/Category:Articles_with_dead_external_links_from_March_2012 (Category:Articles with dead external links from March 2012)
   [276]: /wiki/Category:Use_dmy_dates_from_February_2011 (Category:Use dmy dates from February 2011)

##### Personal tools

  * [Log in][277]
  * [Create account][278]

   [277]: /w/index.php?title=Special:UserLogin&returnto=Closure+%28computer+science%29 (You are encouraged to log in; however, it is not mandatory. [o])
   [278]: /w/index.php?title=Special:UserLogin&returnto=Closure+%28computer+science%29&type=signup

##### Namespaces

  * [Article][279]
  * [Talk][280]

   [279]: /wiki/Closure_(computer_science) (View the content page [c])
   [280]: /wiki/Talk:Closure_(computer_science) (Discussion about the content page [t])

#### 

##### Variants[][281]

   [281]: #

##### Views

  * [Read][282]
  * [Edit][283]
  * [View history][284]

   [282]: /wiki/Closure_(computer_science)
   [283]: /w/index.php?title=Closure_(computer_science)&action=edit (You can edit this page. 
Please use the preview button before saving. [e])
   [284]: /w/index.php?title=Closure_(computer_science)&action=history (Past versions of this page [h])

##### Actions[][285]

   [285]: #

##### Search

![Search][286]

   [286]: //bits.wikimedia.org/static-1.20wmf4/skins/vector/images/search-ltr.png?303-4

[][287]

   [287]: /wiki/Main_Page (Visit the main page)

##### Navigation

  * [Main page][288]
  * [Contents][289]
  * [Featured content][290]
  * [Current events][291]
  * [Random article][292]
  * [Donate to Wikipedia][293]

   [288]: /wiki/Main_Page (Visit the main page [z])
   [289]: /wiki/Portal:Contents (Guides to browsing Wikipedia)
   [290]: /wiki/Portal:Featured_content (Featured content – the best of Wikipedia)
   [291]: /wiki/Portal:Current_events (Find background information on current events)
   [292]: /wiki/Special:Random (Load a random article [x])
   [293]: //donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&utm_medium=sidebar&utm_campaign=20120521SB001&uselang=en (Support us)

##### Interaction

  * [Help][294]
  * [About Wikipedia][295]
  * [Community portal][296]
  * [Recent changes][297]
  * [Contact Wikipedia][298]

   [294]: /wiki/Help:Contents (Guidance on how to use and edit Wikipedia)
   [295]: /wiki/Wikipedia:About (Find out about Wikipedia)
   [296]: /wiki/Wikipedia:Community_portal (About the project, what you can do, where to find things)
   [297]: /wiki/Special:RecentChanges (A list of recent changes in the wiki [r])
   [298]: /wiki/Wikipedia:Contact_us (How to contact Wikipedia)

##### Toolbox

  * [What links here][299]
  * [Related changes][300]
  * [Upload file][301]
  * [Special pages][302]
  * [Permanent link][303]
  * [Cite this page][304]

   [299]: /wiki/Special:WhatLinksHere/Closure_(computer_science) (List of all English Wikipedia pages containing links to this page [j])
   [300]: /wiki/Special:RecentChangesLinked/Closure_(computer_science) (Recent changes in pages linked from this page [k])
   [301]: /wiki/Wikipedia:Upload (Upload files [u])
   [302]: /wiki/Special:SpecialPages (A list of all special pages [q])
   [303]: /w/index.php?title=Closure_(computer_science)&oldid=493854885 (Permanent link to this revision of the page)
   [304]: /w/index.php?title=Special:Cite&page=Closure_(computer_science)&id=493854885 (Information on how to cite this page)

##### Print/export

  * [Create a book][305]
  * [Download as PDF][306]
  * [Printable version][307]

   [305]: /w/index.php?title=Special:Book&bookcmd=book_creator&referer=Closure+%28computer+science%29 (Create a book or page collection)
   [306]: /w/index.php?title=Special:Book&bookcmd=render_article&arttitle=Closure+%28computer+science%29&oldid=493854885&writer=rl (Download a PDF version of this wiki page)
   [307]: /w/index.php?title=Closure_(computer_science)&printable=yes (Printable version of this page [p])

##### Languages

  * [Български][308]
  * [Deutsch][309]
  * [Eesti][310]
  * [Ελληνικά][311]
  * [Español][312]
  * [Français][313]
  * [עברית][314]
  * [Italiano][315]
  * [Nederlands][316]
  * [日本語][317]
  * [Polski][318]
  * [Português][319]
  * [Русский][320]
  * [Simple English][321]
  * [Suomi][322]
  * [ไทย][323]
  * [Українська][324]
  * [中文][325]

   [308]: //bg.wikipedia.org/wiki/%D0%97%D0%B0%D1%82%D0%B2%D0%B0%D1%80%D1%8F%D0%BD%D0%B5_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0) (Затваряне (информатика))
   [309]: //de.wikipedia.org/wiki/Closure (Closure)
   [310]: //et.wikipedia.org/wiki/Sulund_(informaatika) (Sulund (informaatika))
   [311]: //el.wikipedia.org/wiki/%CE%9A%CE%BB%CE%B5%CE%AF%CF%83%CE%B9%CE%BC%CE%BF_(%CE%B5%CF%80%CE%B9%CF%83%CF%84%CE%AE%CE%BC%CE%B7_%CF%85%CF%80%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CF%83%CF%84%CF%8E%CE%BD) (Κλείσιμο (επιστήμη υπολογιστών))
   [312]: //es.wikipedia.org/wiki/Clausura_(inform%C3%A1tica) (Clausura (informática))
   [313]: //fr.wikipedia.org/wiki/Fermeture_(informatique) (Fermeture (informatique))
   [314]: //he.wikipedia.org/wiki/%D7%A1%D7%92%D7%95%D7%A8_(%D7%A9%D7%A4%D7%95%D7%AA_%D7%AA%D7%9B%D7%A0%D7%95%D7%AA) (סגור (שפות תכנות))
   [315]: //it.wikipedia.org/wiki/Chiusura_(informatica) (Chiusura (informatica))
   [316]: //nl.wikipedia.org/wiki/Closure (Closure)
   [317]: //ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3 (クロージャ)
   [318]: //pl.wikipedia.org/wiki/Domkni%C4%99cie_(programowanie) (Domknięcie (programowanie))
   [319]: //pt.wikipedia.org/wiki/Closure_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o) (Closure (ciência da computação))
   [320]: //ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) (Замыкание (программирование))
   [321]: //simple.wikipedia.org/wiki/Closure_(computer_science) (Closure (computer science))
   [322]: //fi.wikipedia.org/wiki/Sulkeuma_(ohjelmointi) (Sulkeuma (ohjelmointi))
   [323]: //th.wikipedia.org/wiki/%E0%B8%AA%E0%B9%88%E0%B8%A7%E0%B8%99%E0%B8%9B%E0%B8%B4%E0%B8%94%E0%B8%84%E0%B8%A5%E0%B8%B8%E0%B8%A1_(%E0%B8%A7%E0%B8%B4%E0%B8%97%E0%B8%A2%E0%B8%B2%E0%B8%81%E0%B8%B2%E0%B8%A3%E0%B8%84%E0%B8%AD%E0%B8%A1%E0%B8%9E%E0%B8%B4%E0%B8%A7%E0%B9%80%E0%B8%95%E0%B8%AD%E0%B8%A3%E0%B9%8C) (ส่วนปิดคลุม (วิทยาการคอมพิวเตอร์))
   [324]: //uk.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D0%B8%D0%BA%D0%B0%D0%BD%D0%BD%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F) (Замикання (програмування))
   [325]: //zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6) (闭包 (计算机科学))

  * This page was last modified on 22 May 2012 at 17:43.  

  * Text is available under the [Creative Commons Attribution-ShareAlike License][326][][327]; additional terms may apply. See [Terms of use][328] for details.  
> Wikipedia&reg; is a registered trademark of the <a href="/www.wikimediafoundation.org/">Wikimedia Foundation, Inc., a non-profit organization.  

  * [Contact us][329]

   [326]: //en.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License
   [327]: //creativecommons.org/licenses/by-sa/3.0/
   [328]: //wikimediafoundation.org/wiki/Terms_of_use
   [329]: //en.wikipedia.org/wiki/Wikipedia:Contact_us

  * [Privacy policy][330]
  * [About Wikipedia][331]
  * [Disclaimers][332]
  * [Mobile view][333]

   [330]: //wikimediafoundation.org/wiki/Privacy_policy (wikimedia:Privacy policy)
   [331]: /wiki/Wikipedia:About (Wikipedia:About)
   [332]: /wiki/Wikipedia:General_disclaimer (Wikipedia:General disclaimer)
   [333]: http://en.m.wikipedia.org/w/index.php?title=Closure_(computer_science)&mobileaction=toggle_view_mobile

  * [![Wikimedia Foundation][334]][335]
  * [![Powered by MediaWiki][336]][337]

   [334]: //bits.wikimedia.org/images/wikimedia-button.png
   [335]: //wikimediafoundation.org/
   [336]: //bits.wikimedia.org/static-1.20wmf4/skins/common/images/poweredby_mediawiki_88x31.png
   [337]: //www.mediawiki.org/

